#utils/fetch_top_n_volatility_volume.py
import requests
import sys
from utils.logger import log

API_URL = "https://api.backpack.exchange/api/v1/tickers"
OUTPUT_FILE = "symbol.lst"

def fetch_top_n_volatility_volume(n=None):
    """
    R√©cup√®re les N symboles les plus volatils avec un volume >= 1M.
    
    Args:
        n (int, optional): Nombre de symboles √† retourner. Si None, retourne tous.
    
    Returns:
        list: Liste des symboles tri√©s par score (volatilit√© * volume normalis√©)
    """
    try:
        log("üîÑ R√©cup√©ration des donn√©es depuis l'API Backpack...", level="DEBUG")
        resp = requests.get(API_URL, timeout=30)
        resp.raise_for_status()
    except requests.exceptions.RequestException as e:
        log(f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es API : {e}", level="ERROR")
        return []
    except Exception as e:
        log(f"‚ùå Erreur inattendue lors de la r√©cup√©ration des donn√©es : {e}", level="ERROR")
        return []

    try:
        data = resp.json()
    except Exception as e:
        log(f"‚ùå Erreur lors du parsing JSON : {e}", level="ERROR")
        return []

    if not isinstance(data, list):
        log(f"‚ùå Format de donn√©es inattendu. Attendu: liste, re√ßu: {type(data)}", level="ERROR")
        return []

    # Filtrer uniquement les contrats perp√©tuels
    perp_tickers = [t for t in data if isinstance(t, dict) and "_PERP" in t.get("symbol", "")]
    log(f"üìä {len(perp_tickers)} contrats perp√©tuels trouv√©s", level="DEBUG")

    if not perp_tickers:
        log(f"‚ùå Aucun contrat perp√©tuel trouv√©", level="ERROR")
        return []

    tickers_data = []
    for t in perp_tickers:
        try:
            symbol = t["symbol"]
            price_change_percent = abs(float(t.get("priceChangePercent", 0)))
            volume = float(t.get("volume", 0))
            
            # Validation des donn√©es
            if volume > 0 and price_change_percent >= 0:
                tickers_data.append((symbol, price_change_percent, volume))
        except (ValueError, TypeError, KeyError) as e:
            log(f"‚ö†Ô∏è Donn√©es invalides pour un ticker : {e}", level="DEBUG")
            continue

    if not tickers_data:
        log(f"‚ùå Aucune donn√©e de ticker valide trouv√©e", level="ERROR")
        return []

    # Filtrer par volume minimum (1 million)
    min_volume = 1_000_000
    tickers_data = [
        (symbol, price_change_percent, volume)
        for symbol, price_change_percent, volume in tickers_data
        if volume >= min_volume
    ]

    if not tickers_data:
        log(f"‚ùå Aucun ticker avec un volume >= {min_volume:,}", level="ERROR")
        return []

    log(f"üìà {len(tickers_data)} tickers avec volume >= {min_volume:,}", level="DEBUG")

    # Calculer les scores (volatilit√© * volume normalis√©)
    max_volume = max(t[2] for t in tickers_data)
    
    if max_volume == 0:
        log(f"‚ùå Volume maximum est 0, impossible de calculer les scores", level="ERROR")
        return []

    scored_tickers = []
    for symbol, volat, vol in tickers_data:
        volume_norm = vol / max_volume
        score = volat * volume_norm
        scored_tickers.append((symbol, score))

    # Trier par score d√©croissant
    scored_tickers.sort(key=lambda x: x[1], reverse=True)

    # Limiter le nombre de r√©sultats si sp√©cifi√©
    if n is None:
        top_n = scored_tickers
        log(f"üìã Tous les {len(scored_tickers)} symboles retourn√©s (pas de limite)", level="DEBUG")
    else:
        top_n = scored_tickers[:n]
        log(f"üìã Top {len(top_n)} symboles retourn√©s", level="DEBUG")

    # Extraire uniquement les symboles
    symbols_list = [symbol for symbol, score in top_n]

    # Log des r√©sultats
    if symbols_list:
        log(f"‚úÖ {len(symbols_list)} symboles r√©cup√©r√©s : {symbols_list[:5]}{'...' if len(symbols_list) > 5 else ''}", level="DEBUG")
    else:
        log(f"‚ö†Ô∏è Aucun symbole retourn√©", level="WARNING")

    return symbols_list


def save_symbols_to_file(symbols_list, filename=OUTPUT_FILE):
    """
    Sauvegarde la liste des symboles dans un fichier.
    
    Args:
        symbols_list (list): Liste des symboles
        filename (str): Nom du fichier de sortie
    """
    try:
        with open(filename, "w") as f:
            for symbol in symbols_list:
                f.write(f"{symbol}\n")
        log(f"üíæ Symboles sauvegard√©s dans {filename}", level="DEBUG")
    except Exception as e:
        log(f"‚ùå Erreur lors de la sauvegarde dans {filename} : {e}", level="ERROR")


if __name__ == "__main__":
    # Parse argument avec --no-limit support
    if len(sys.argv) == 2:
        arg = sys.argv[1]
        if arg == "--no-limit":
            n = None
        else:
            try:
                n = int(arg)
                if n <= 0:
                    print("N doit √™tre un entier positif")
                    sys.exit(1)
            except ValueError:
                print("N doit √™tre un entier ou --no-limit")
                sys.exit(1)
    else:
        print(f"Usage: python3 {sys.argv[0]} N | --no-limit")
        print("  N : nombre de symboles √† r√©cup√©rer")
        print("  --no-limit : r√©cup√©rer tous les symboles")
        sys.exit(1)

    # Appeler la fonction et sauvegarder les r√©sultats
    symbols = fetch_top_n_volatility_volume(n)
    
    if symbols:
        save_symbols_to_file(symbols)
        print(f"‚úÖ {len(symbols)} symboles r√©cup√©r√©s et sauvegard√©s dans {OUTPUT_FILE}")
        for i, symbol in enumerate(symbols, 1):
            print(f"  {i:2d}. {symbol}")
    else:
        print("‚ùå Aucun symbole r√©cup√©r√©")
        sys.exit(1)