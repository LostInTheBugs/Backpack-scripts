{
    "symbols": {
        "update_auto": "🔄 Mise à jour symboles auto : {}",
        "update_error": "❌ Erreur maj symboles auto: {}",
        "active": "✅ Symboles actifs ({}) : {}",
        "ignored": "⛔ Symboles ignorés ({}) : {}",
        "no_active": "⚠️ Aucun symbole actif pour cette itération.",
        "file_reloaded": "🔁 symbol.lst rechargé : {}",
        "table_missing": "{} (table absente)",
        "inactive_since": "{} (inactif depuis {})"
    },
    "system": {
        "manual_stop": "🛑 Arrêt manuel demandé",
        "manual_stop_ctrl_c": "🛑 Arrêt manuel demandé (Ctrl+C)",
        "watcher_error": "💥 Erreur dans le watcher : {}",
        "pool_closed": "Pool de connexion fermé, fin du programme.",
        "clean_shutdown": "🛑 Arrêt manuel demandé via KeyboardInterrupt, fermeture propre..."
    },
    "backtest": {
        "launch": "[{}] 🧪 Lancement du backtest {}h avec stratégie {}",
        "no_ohlcv_data": "❌ Pas de données OHLCV en base pour backtest",
        "error_fetch_ohlcv": "❌ Erreur fetch OHLCV backtest: {}",
        "no_data": "❌ Pas de données OHLCV",
        "start": "✅ Début du backtest avec {} bougies",
        "end": "🔚 Backtest terminé",
        "stats_positions": "📊 Positions: {} | Gagnantes: {} | Perdantes: {}",
        "stats_pnl": "📈 PnL total: {:.2f}% | moyen: {:.2f}% | médian: {:.2f}% | taux de succès: {:.2f}%",
        "no_positions": "⚠️ Aucune position prise",
        "exception": "💥 Exception dans le backtest complet: {}",
        "info_filter_duration": "🔎 Filtrage des données sur les dernières {:.2f} heures",
        "info_filter_dates": "🔎 Filtrage des données entre {} et {}",
        "no_data_after_filter": "❌ Pas de données après filtrage"
    },
    "time": {
        "seconds": "{}s",
        "minutes": "{}min"
    },
    "order": {
        "invalid_direction": "❌ Direction invalide. Utilisez 'long' ou 'short'.",
        "invalid_amount": "❌ Le montant en USDC doit être supérieur à zéro.",
        "market_list_failed": "❌ Échec de récupération de la liste des marchés.",
        "symbol_not_found": "❌ Symbole '{}' introuvable.",
        "ticker_failed": "❌ Échec de récupération des données du ticker.",
        "invalid_price": "❌ Prix invalide renvoyé par le ticker.",
        "below_min_qty": "❌ La quantité {0} est inférieure au minimum autorisé ({1}) pour {2}.",
        "increase_amount": "➡️ Augmentez votre montant en USDC ou choisissez un autre symbole.",
        "invalid_qty_or_price": "⚠️ Quantité ou prix non valides pour ce marché.",
        "step_error": " ➤ La quantité {0} ne respecte pas le stepSize ({1})",
        "tick_error": " ➤ Le prix {0} ne respecte pas le tickSize ({1})",
        "adjusted_qty": "✅ Quantité ajustée : {0}",
        "adjusted_price": "✅ Prix ajusté      : {0:.{1}f}",
        "dry_run": "[DRY RUN] Ordre {0} {1} sur {2} pour {3:.2f} USDC ≈ {4} unités (simulation)",
        "submitting": "🚀 Envoi de l'ordre {0} {1} sur {2} pour {3:.2f} USDC ≈ {4} unités",
        "invalid_response": "❌ Réponse invalide de l'exécution d'ordre.",
        "response": "✅ Réponse de l'ordre :",
        "usage": "Usage: python open_position_usdc.py <SYMBOL> <USDC_AMOUNT> <DIRECTION> [--dry-run]\nExemple: python open_position_usdc.py SOL_USDC_PERP 25 long --dry-run",
        "amount_must_be_number": "❌ Le montant USDC doit être un nombre.",
        "market_info": "📊 Données marché pour {0} :"
    },
    "config": {
        "loaded": "✅ Configuration chargée depuis {}",
        "error": "❌ Erreur de chargement de la configuration : {}",
        "missing_file": "❌ Fichier de configuration manquant : {}",
        "invalid_format": "❌ Format de configuration invalide : {}"
    },
    "general": {
        "starting": "🚀 Démarrage du script...",
        "stopping": "🛑 Arrêt du script...",
        "error": "💥 Erreur : {}",
        "success": "✅ Succès : {}"
    },
    "live_engine": {
        "trailing_stop": {
            "initialized": "[{symbol}] 🎯 Trailing stop initialisé à {percentage:.1f}%",
            "updated": "[{symbol}] 📈 Trailing stop mis à jour: {prev:.1f}% → {new:.1f}%",
            "error": "[{symbol}] ❌ Erreur calcul trailing stop: {error}",
            "cleaned": "[{symbol}] 🧹 Trailing stop nettoyé de la mémoire",
            "triggered": "Trailing stop déclenché: PnL {pnl:.2f}% <= Trailing {trailing:.2f}%",
            "closing": "[{symbol}] 🎯 Fermeture position suite au déclenchement trailing stop"
        },
        "indicators": {
            "rsi_retrieved": "[{symbol}] ✅ RSI récupéré via API: {rsi:.2f}",
            "rsi_error_fallback": "[{symbol}] ⚠️ Erreur RSI API, tentative calcul local: {error}",
            "rsi_calculated": "[{symbol}] 🔄 RSI calculé localement: {rsi:.2f}",
            "rsi_failed": "[{symbol}] ⚠️ Impossible de calculer RSI localement, valeur neutre: {error}",
            "macd_calculated": "[{symbol}] ✅ MACD calculé automatiquement",
            "missing": "[{symbol}] ⚠️ Indicateurs manquants: {missing} — signal ignoré",
            "nan_detected": "[{symbol}] ⚠️ NaN détecté dans {column} — signal ignoré",
            "calculation_failed": "[{symbol}] ❌ Échec calcul des indicateurs"
        },
        "data": {
            "loading": "[{symbol}] 📈 Chargement données OHLCV pour {interval}",
            "no_recent": "[{symbol}] ❌ Ignoré: pas de données récentes en base locale",
            "no_1s_data": "[{symbol}] ❌ Aucune donnée 1s récupérée de la base locale",
            "dataframe_validated": "[{symbol}] DataFrame validé - shape: {shape}, columns: {columns}",
            "dataframe_empty": "[{symbol}] ⚠️ DataFrame vide après calcul des indicateurs",
            "dataframe_error": "[{symbol}] ❌ Attendu DataFrame mais reçu {type}"
        },
        "strategy": {
            "market_detected": "[{symbol}] 📊 Marché détecté: {condition} — Stratégie sélectionnée: {strategy}",
            "manual_selected": "[{symbol}] 📊 Stratégie sélectionnée manuellement: {strategy}",
            "about_to_call": "[{symbol}] Sur le point d'appeler la stratégie: {strategy}",
            "calling_async": "[{symbol}] 🔄 Appel fonction stratégie async",
            "calling_sync": "[{symbol}] 🔄 Appel fonction stratégie sync",
            "returned": "[{symbol}] Stratégie retournée: {type} - {result}",
            "error": "[{symbol}] ❌ Erreur appel fonction stratégie: {error}"
        },
        "signals": {
            "detected": "[{symbol}] 🎯 Signal détecté: {signal} | Détails: {details}",
            "try_open": "{symbol} 🚨 Tentative ouverture position: {signal}",
            "no_actionable": "{symbol} ❌ Aucun signal actionnable détecté: {signal}"
        },
        "positions": {
            "opened_success": "[{symbol}] ✅ Position ouverte avec succès",
            "closed_success": "[{symbol}] ✅ Position fermée avec succès",
            "opening_real": "[{symbol}] ✅ Ouverture position RÉELLE: {direction}",
            "opening_dry": "[{symbol}] 🧪 DRY-RUN: Simulation ouverture position {direction}",
            "open_error": "[{symbol}] ❌ Erreur ouverture position: {error}",
            "close_error": "[{symbol}] ❌ Erreur fermeture position: {error}",
            "no_valid_found": "[{symbol}] ⚠️ Aucune position ouverte valide trouvée",
            "unexpected_pnl_type": "[{symbol}] ⚠️ Type de retour inattendu de get_real_pnl: {type}",
            "limit_reached": "[{symbol}] ⚠️ Limite max positions ({max}) atteinte - ignoré",
            "neither_run_mode": "[{symbol}] ❌ Ni --real-run ni --dry-run spécifié: aucune action"
        },
        "scan": {
            "launch": "🔍 Lancement du scan indicateurs…",
            "launch_trade": "🔍 Lancement du scan indicateurs et trading en parallèle…",
            "unexpected_result": "⚠️ Résultat inattendu dans scan_all_symbols: {result}",
            "ok_symbols": "✅ OK: {symbols}",
            "ko_symbols": "❌ KO: {symbols}",
            "summary": "📊 Résumé: {ok_count} OK / {ko_count} KO sur {total} paires"
        },
        "debug": {
            "ensure_indicators_type": "[{symbol}] ensure_indicators returned type: {type}",
            "is_coroutine": "[{symbol}] Is coroutine? {is_coroutine}",
            "awaiting_coroutine": "[{symbol}] Awaiting coroutine from ensure_indicators...",
            "function_type": "[{symbol}] Function type: {type}",
            "is_coroutine_function": "[{symbol}] Is coroutine function? {is_coroutine}",
            "dataframe_before_call": "[{symbol}] DataFrame type before call: {type}",
            "dataframe_shape": "[{symbol}] DataFrame shape: {shape}",
            "close_check": "[{symbol}] CLOSE CHECK: PnL={pnl:.2f}%, Trailing={trailing}, Duration={duration}s, ShouldClose={should_close}",
            "pnl_calculation": "[{symbol}] DEBUG PnL calculation: pnl_data={pnl_data}, type={type}",
            "pnl_details": "[{symbol}] DEBUG: entry={entry}, mark={mark}, pnl_pct={pnl_pct}, pnl_usd={pnl_usd}"
        },
        "errors": {
            "generic": "[{symbol}] 💥 Erreur: {error}",
            "position_handling": "[{symbol}] ❌ Erreur dans handle_existing_position: {error}",
            "position_limit": "⚠️ Erreur vérification limite positions: {error}",
            "position_stats": "⚠️ Erreur récupération stats positions: {error}",
            "dataframe_info": "[{symbol}] Infos DataFrame au moment de l'erreur:",
            "dataframe_type": "[{symbol}]   - Type: {type}",
            "dataframe_is_coroutine": "[{symbol}]   - Is coroutine? {is_coroutine}",
            "dataframe_shape_error": "[{symbol}]   - Shape: {shape}",
            "dataframe_columns_error": "[{symbol}]   - Columns: {columns}"
        },
        "stop_loss": {
            "fixed_triggered": "Stop loss fixe déclenché: PnL {pnl:.2f}% <= Stop Loss {stop_loss:.2f}%",
            "check_error": "Erreur vérification stop loss fixe: {error}"
        }
    }, 
    "utils": {
        "logger": {
            "write_error": "[❌] Erreur écriture log : {error}"
        },
        "public": {
            "ohlcv_called": " get_ohlcv called with startTime={startTime}",
            "ohlcv_error": " get_ohlcv(): {error}",
            "table_not_exists": "❌ Table {table_name} n'existe pas.",
            "table_check_error": "❌ Erreur lors de la vérification de la table {table_name}: {error}"
        },
        "fetch_symbols": {
            "must_be_positive": "N doit être un entier positif",
            "must_be_integer": "N doit être un entier ou --no-limit",
            "usage": "Usage: python3 {script} N | --no-limit",
            "usage_n": "  N : nombre de symboles à récupérer",
            "usage_no_limit": "  --no-limit : récupérer tous les symboles",
            "symbols_saved": "✅ {count} symboles récupérés et sauvegardés dans {file}",
            "symbol_item": "  {i:2d}. {symbol}",
            "no_symbols": "❌ Aucun symbole récupéré"
        }
    }
}